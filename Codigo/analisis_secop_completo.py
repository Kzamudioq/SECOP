# -*- coding: utf-8 -*-
"""analisis_secop_completo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-s1LCCHQKdb5cI6OicRgsxYalWGZzEgN

# **An√°lisis de Datos SECOP - Colombia**


## An√°lisis de Contrataci√≥n P√∫blica

**¬øQu√© vamos a hacer?**
-  Descargar datos reales de contrataci√≥n p√∫blica
-  Limpiar y procesar la informaci√≥n
-  Crear visualizaciones interactivas
-  Analizar redes de colaboraci√≥n
-  Detectar patrones interesantes

**Solo ejecuta las celdas una por una y disfruta del an√°lisis**

## Instalaci√≥n de librerias
"""

#  INSTALACI√ìN Y CONFIGURACI√ìN INICIAL
print(" Configurando entorno de an√°lisis...")

# Instalar librer√≠as necesarias
!pip install fuzzywuzzy python-Levenshtein networkx plotly kaleido -q

# ====================================================================
# LIBRER√çAS PARA AN√ÅLISIS DE DATOS, SOLICITUDES Y VISUALIZACI√ìN
# ====================================================================

import pandas as pd        # Manipulaci√≥n y an√°lisis de datos (tablas tipo Excel o CSV)
import numpy as np          # C√°lculos num√©ricos y manejo de arreglos (vectores, matrices)
import requests             # Env√≠o de solicitudes HTTP (consultar APIs o p√°ginas web)
import time                 # Control de tiempos y pausas en la ejecuci√≥n del programa
import warnings             # Ocultar o controlar advertencias del sistema

# ====================================================================
# LIBRER√çAS PARA VISUALIZACI√ìN INTERACTIVA CON PLOTLY
# ====================================================================

import plotly.express as px # Gr√°ficos interactivos sencillos (barras, dispersi√≥n, mapas, etc.)
import plotly.graph_objects as go   # Gr√°ficos avanzados y personalizados (m√°s control)
from plotly.subplots import make_subplots  # Permite combinar varios gr√°ficos en una misma figura
import plotly.io as pio     # Configuraci√≥n de visualizaci√≥n y exportaci√≥n (HTML, PNG, etc.)

# ====================================================================
# LIBRER√çAS PARA AN√ÅLISIS DE REDES, COMBINACIONES Y COINCIDENCIAS DE TEXTO
# ====================================================================

import networkx as nx       # Creaci√≥n y an√°lisis de grafos/redes (nodos y relaciones)
import itertools            # Combinaciones, permutaciones y operaciones sobre iteradores
from fuzzywuzzy import fuzz, process  # Comparaci√≥n de texto difusa (emparejamiento aproximado)

# ====================================================================
# LIBRER√çA PARA MOSTRAR BARRAS DE PROGRESO
# ====================================================================

from tqdm import tqdm        # Barra de progreso en loops largos para seguimiento visual

# Configuraciones
pio.renderers.default = "colab"
warnings.filterwarnings('ignore')

print(" ¬°Listo! Todas las herramientas configuradas")

"""## Descarga de datos"""

# DESCARGA DE DATOS DE SECOP - VERSI√ìN COMPLETA
print("Descargando datos de SECOP...")
print("Esto puede tomar unos minutos...")

def descargar_secop_completo(url, filtros=None):
    """Descarga TODOS los datos de SECOP con paginaci√≥n autom√°tica"""
    limit = 50000  # M√°ximo por request de la API
    offset = 0
    all_data = []

    print(f"Iniciando descarga desde: {url}")

    while True:
        params = {"$limit": limit, "$offset": offset}
        if filtros:
            params.update(filtros)

        try:
            print(f"Solicitando registros {offset:,} - {offset + limit:,}...")
            response = requests.get(url, params=params, timeout=60)
            response.raise_for_status()  # Lanza excepci√≥n si hay error HTTP

            data = response.json()

            # Si no hay datos, hemos llegado al final
            if not data or len(data) == 0:
                print("No hay m√°s datos disponibles.")
                break

            all_data.append(pd.DataFrame(data))
            registros_actuales = len(data)
            total_descargado = sum(len(df) for df in all_data)

            print(f"‚úì Descargados: {registros_actuales:,} registros (Total acumulado: {total_descargado:,})")

            # Si recibimos menos registros que el l√≠mite, hemos llegado al final
            if registros_actuales < limit:
                print("Llegamos al final de los datos disponibles.")
                break

            offset += limit

            # Peque√±a pausa para no sobrecargar la API
            time.sleep(0.5)

        except requests.exceptions.RequestException as e:
            print(f"Error de conexi√≥n: {e}")
            print("Reintentando en 5 segundos...")
            time.sleep(5)
            continue

        except Exception as e:
            print(f"Error inesperado: {e}")
            print("Deteniendo descarga...")
            break

    if all_data:
        resultado = pd.concat(all_data, ignore_index=True)
        print(f"Descarga completada: {len(resultado):,} registros totales")
        return resultado
    else:
        print("No se descargaron datos")
        return pd.DataFrame()

# URLs de datos
url_contratos = "https://www.datos.gov.co/resource/jbjy-vk9h.json"
url_grupos = "https://www.datos.gov.co/resource/ceth-n4bn.json"

# Filtro para Bogot√° desde 2021 (mant√©n tus filtros si los necesitas)
filtros_bogota = {
    "$where": "departamento = 'Distrito Capital de Bogot√°' AND fecha_de_firma >= '2021-01-01T00:00:00.000'"
}

# Importar time si no est√° importado
import time

# Descargar TODOS los datos
print("=" * 60)
print("DESCARGANDO TODOS LOS CONTRATOS DE BOGOT√Å...")
print("=" * 60)
df_contratos = descargar_secop_completo(url_contratos, filtros_bogota)

print("\n" + "=" * 60)
print("DESCARGANDO TODOS LOS GRUPOS EMPRESARIALES...")
print("=" * 60)
df_grupos = descargar_secop_completo(url_grupos)

print(f"\nRESUMEN FINAL:")
print(f"   Contratos: {len(df_contratos):,}")
print(f"   Grupos: {len(df_grupos):,}")
print(f"   Memoria total estimada: {(df_contratos.memory_usage().sum() + df_grupos.memory_usage().sum()) / 1024**2:.1f} MB")

# DESCARGA PARCIAL DE DATOS DE SECOP
print("Descargando datos de SECOP...")
print("Esto puede tomar unos minutos...")

def descargar_secop(url, filtros=None, max_registros=50000):
    """Descarga datos de SECOP con paginaci√≥n"""
    limit = 50000
    offset = 0
    all_data = []

    while len(all_data) * limit < max_registros:
        params = {"$limit": limit, "$offset": offset}
        if filtros:
            params.update(filtros)

        try:
            response = requests.get(url, params=params, timeout=60)
            data = response.json()

            if not data:
                break

            all_data.append(pd.DataFrame(data))
            print(f"Descargados: {len(data):,} registros (total: {sum(len(df) for df in all_data):,})")

            offset += limit
            if len(data) < limit:
                break

        except Exception as e:
            print(f"Error: {e}")
            break

    return pd.concat(all_data, ignore_index=True) if all_data else pd.DataFrame()

# URLs de datos
url_contratos = "https://www.datos.gov.co/resource/jbjy-vk9h.json"
url_grupos = "https://www.datos.gov.co/resource/ceth-n4bn.json"

# Filtro para Bogot√° desde 2021
filtros_bogota = {
    "$where": "departamento = 'Distrito Capital de Bogot√°' AND fecha_de_firma >= '2021-01-01T00:00:00.000'"
}

# Descargar datos
print("Descargando contratos de Bogot√°...")
df_contratos = descargar_secop(url_contratos, filtros_bogota, 100000)

print("\nDescargando datos de grupos empresariales...")
df_grupos = descargar_secop(url_grupos, max_registros=50000)

print(f"\nDescarga completada:")
print(f"   Contratos: {len(df_contratos):,}")
print(f"   Grupos: {len(df_grupos):,}")

# LIMPIEZA Y PROCESAMIENTO DE DATOS
print("Procesando y limpiando datos...")

# Funci√≥n para limpiar nombres
def limpiar_texto(serie):
    return (serie.astype(str)
            .str.replace('.', '', regex=False)
            .str.strip()
            .str.replace(r'\s+', ' ', regex=True)
            .str.upper()
            .replace('NAN', ''))

# Funci√≥n para procesar valores monetarios
def procesar_valores(serie):
    return (serie.astype(str)
            .str.replace(r'[\$,]', '', regex=True)
            .str.replace(r'[^\d.]', '', regex=True)
            .replace('', '0')
            .astype(float))

if not df_contratos.empty:
    # Identificar columnas clave
    cols_valor = [col for col in df_contratos.columns if 'valor' in col.lower()]
    cols_entidad = [col for col in df_contratos.columns if 'entidad' in col.lower()]
    cols_proveedor = [col for col in df_contratos.columns if 'proveedor' in col.lower()]

    print(f"Columnas encontradas:")
    print(f"   Valor: {cols_valor[:2]}")
    print(f"   Entidad: {cols_entidad[:2]}")
    print(f"   Proveedor: {cols_proveedor[:2]}")

    # Procesar datos
    if cols_valor:
        df_contratos['valor_limpio'] = procesar_valores(df_contratos[cols_valor[0]])

    if cols_entidad:
        df_contratos['entidad_limpia'] = limpiar_texto(df_contratos[cols_entidad[0]])

    if cols_proveedor:
        df_contratos['proveedor_limpio'] = limpiar_texto(df_contratos[cols_proveedor[0]])

# Procesar grupos empresariales
if not df_grupos.empty:
    if 'nombre_participante' in df_grupos.columns:
        df_grupos['participante_limpio'] = limpiar_texto(df_grupos['nombre_participante'])

    if 'participacion' in df_grupos.columns:
        df_grupos['participacion_num'] = pd.to_numeric(df_grupos['participacion'], errors='coerce').fillna(0)

print("Procesamiento completado")

# ESTAD√çSTICAS B√ÅSICAS
print("RESUMEN EJECUTIVO DE DATOS")
print("=" * 50)

if not df_contratos.empty:
    # Estad√≠sticas generales
    total_contratos = len(df_contratos)

    if 'valor_limpio' in df_contratos.columns:
        valor_total = df_contratos['valor_limpio'].sum()
        valor_promedio = df_contratos['valor_limpio'].mean()
        valor_mediano = df_contratos['valor_limpio'].median()

        print(f"AN√ÅLISIS FINANCIERO:")
        print(f"   Total contratos: {total_contratos:,}")
        print(f"   Valor total: ${valor_total:,.0f} COP")
        print(f"   Valor promedio: ${valor_promedio:,.0f} COP")
        print(f"   Valor mediano: ${valor_mediano:,.0f} COP")
        print(f"   En billones: ${valor_total/1_000_000_000_000:.2f} billones COP")

    if 'entidad_limpia' in df_contratos.columns:
        entidades_unicas = df_contratos['entidad_limpia'].nunique()
        top_entidad = df_contratos['entidad_limpia'].value_counts().index[0]
        contratos_top = df_contratos['entidad_limpia'].value_counts().iloc[0]

        print(f"\nAN√ÅLISIS DE ENTIDADES:")
        print(f"   Total entidades: {entidades_unicas:,}")
        print(f"   Entidad m√°s activa: {top_entidad[:60]}...")
        print(f"   Sus contratos: {contratos_top:,}")

    if 'proveedor_limpio' in df_contratos.columns:
        proveedores_unicos = df_contratos['proveedor_limpio'].nunique()
        print(f"\nAN√ÅLISIS DE PROVEEDORES:")
        print(f"   Total proveedores: {proveedores_unicos:,}")

if not df_grupos.empty:
    print(f"\nGRUPOS EMPRESARIALES:")
    print(f"   Total registros de grupos: {len(df_grupos):,}")
    if 'participante_limpio' in df_grupos.columns:
        participantes_unicos = df_grupos['participante_limpio'].nunique()
        print(f"   Participantes √∫nicos: {participantes_unicos:,}")

print("\n" + "=" * 50)

# VISUALIZACIONES MEJORADAS - PALETA AZUL PROFESIONAL
print("Creando visualizaciones con dise√±o mejorado...")

# Configuraci√≥n de colores azules
colores_azul = {
    'primario': '#1f77b4',
    'secundario': '#aec7e8',
    'degradado': ['#08306b', '#08519c', '#2171b5', '#4292c6', '#6baed6', '#9ecae1', '#c6dbef', '#deebf7'],
    'fondo': '#f8f9fa',
    'texto': '#2c3e50'
}

if not df_contratos.empty and 'entidad_limpia' in df_contratos.columns:
    # üìä Gr√°fico 1: Top entidades - Barras horizontales mejoradas
    top_entidades = df_contratos['entidad_limpia'].value_counts().head(12)
    entidades_cortas = [name[:45] + "..." if len(name) > 45 else name for name in top_entidades.index]

    fig1 = px.bar(
        x=top_entidades.values,
        y=entidades_cortas,
        orientation='h',
        title='üè¢ Top 12 Entidades por N√∫mero de Contratos',
        labels={'x': 'N√∫mero de Contratos', 'y': 'Entidad'},
        color=top_entidades.values,
        color_continuous_scale='Blues'
    )

    fig1.update_layout(
        height=550,
        showlegend=False,
        plot_bgcolor=colores_azul['fondo'],
        paper_bgcolor='white',
        font={'family': 'Arial, sans-serif', 'color': colores_azul['texto'], 'size': 12},
        title={'font': {'size': 16, 'color': colores_azul['texto']}, 'x': 0.5},
        xaxis=dict(gridcolor='lightgray'),
        yaxis=dict(title='')
    )

    fig1.update_traces(
        texttemplate='%{x:,}',
        textposition='outside',
        hovertemplate='<b>%{y}</b><br>Contratos: %{x:,}<extra></extra>'
    )

    fig1.show()

if not df_contratos.empty and 'valor_limpio' in df_contratos.columns:
    # üí∞ Gr√°fico 2: Distribuci√≥n de valores - Histograma mejorado
    valores_validos = df_contratos[df_contratos['valor_limpio'] > 0]['valor_limpio']

    if not valores_validos.empty:
        log_valores = np.log10(valores_validos + 1)

        fig2 = px.histogram(
            x=log_valores,
            nbins=40,
            title='üí∞ Distribuci√≥n de Valores de Contratos (Escala Logar√≠tmica)',
            labels={'x': 'Log‚ÇÅ‚ÇÄ(Valor del Contrato)', 'y': 'N√∫mero de Contratos'},
            color_discrete_sequence=[colores_azul['primario']]
        )

        fig2.update_layout(
            height=450,
            showlegend=False,
            plot_bgcolor=colores_azul['fondo'],
            paper_bgcolor='white',
            font={'family': 'Arial, sans-serif', 'color': colores_azul['texto'], 'size': 12},
            title={'font': {'size': 16, 'color': colores_azul['texto']}, 'x': 0.5},
            xaxis=dict(
                gridcolor='lightgray',
                tickvals=[3, 4, 5, 6, 7, 8, 9, 10],
                ticktext=['$1K', '$10K', '$100K', '$1M', '$10M', '$100M', '$1B', '$10B']
            ),
            yaxis=dict(gridcolor='lightgray')
        )

        fig2.update_traces(
            marker_line_color='white',
            marker_line_width=1,
            opacity=0.8,
            hovertemplate='Rango: %{x:.1f}<br>Contratos: %{y}<extra></extra>'
        )

        fig2.show()

# üìà Gr√°fico 3: Evoluci√≥n temporal MEJORADA
fecha_cols = [col for col in df_contratos.columns if 'fecha' in col.lower()]
if fecha_cols:
    try:
        df_contratos['fecha_parsed'] = pd.to_datetime(df_contratos[fecha_cols[0]], errors='coerce')

        # An√°lisis por mes
        contratos_mensuales = df_contratos.groupby(
            df_contratos['fecha_parsed'].dt.to_period('M')
        ).agg({
            'valor_limpio': 'sum',
            'entidad_limpia': 'count'
        }).reset_index()

        contratos_mensuales['periodo_str'] = contratos_mensuales['fecha_parsed'].astype(str)
        contratos_mensuales['valor_millones'] = contratos_mensuales['valor_limpio'] / 1_000_000

        if not contratos_mensuales.empty:
            # Gr√°fico de l√≠neas para contratos
            fig3 = px.line(
                contratos_mensuales,
                x='periodo_str',
                y='entidad_limpia',
                title='üìà Evoluci√≥n Mensual - N√∫mero de Contratos',
                labels={'entidad_limpia': 'N√∫mero de Contratos', 'periodo_str': 'Per√≠odo'},
                color_discrete_sequence=[colores_azul['primario']]
            )

            fig3.update_layout(
                height=450,
                plot_bgcolor=colores_azul['fondo'],
                paper_bgcolor='white',
                font={'family': 'Arial, sans-serif', 'color': colores_azul['texto'], 'size': 12},
                title={'font': {'size': 16, 'color': colores_azul['texto']}, 'x': 0.5},
                xaxis=dict(gridcolor='lightgray', tickangle=45),
                yaxis=dict(gridcolor='lightgray')
            )

            fig3.update_traces(
                mode='lines+markers',
                line=dict(width=3),
                marker=dict(size=6),
                fill='tonexty',
                hovertemplate='%{x}<br>Contratos: %{y:,}<extra></extra>'
            )

            fig3.show()

            # Gr√°fico de valores
            fig4 = px.line(
                contratos_mensuales,
                x='periodo_str',
                y='valor_millones',
                title='üí∞ Evoluci√≥n Mensual - Valor Total (Millones COP)',
                labels={'valor_millones': 'Millones COP', 'periodo_str': 'Per√≠odo'},
                color_discrete_sequence=[colores_azul['degradado'][2]]
            )

            fig4.update_layout(
                height=450,
                plot_bgcolor=colores_azul['fondo'],
                paper_bgcolor='white',
                font={'family': 'Arial, sans-serif', 'color': colores_azul['texto'], 'size': 12},
                title={'font': {'size': 16, 'color': colores_azul['texto']}, 'x': 0.5},
                xaxis=dict(gridcolor='lightgray', tickangle=45),
                yaxis=dict(gridcolor='lightgray')
            )

            fig4.update_traces(
                mode='lines+markers',
                line=dict(width=3),
                marker=dict(size=6),
                fill='tonexty',
                hovertemplate='%{x}<br>Valor: $%{y:,.0f}M COP<extra></extra>'
            )

            fig4.show()

            # üéØ An√°lisis anual si hay suficientes datos
            if len(contratos_mensuales) > 12:
                contratos_anuales = df_contratos.groupby(
                    df_contratos['fecha_parsed'].dt.year
                ).agg({
                    'valor_limpio': ['sum', 'count'],
                    'entidad_limpia': 'nunique'
                }).reset_index()

                contratos_anuales.columns = ['a√±o', 'valor_total', 'num_contratos', 'entidades_unicas']
                contratos_anuales['valor_total_miles_millones'] = contratos_anuales['valor_total'] / 1_000_000_000

                fig5 = px.bar(
                    contratos_anuales,
                    x='a√±o',
                    y='num_contratos',
                    title='üìä Contratos por A√±o',
                    labels={'num_contratos': 'N√∫mero de Contratos', 'a√±o': 'A√±o'},
                    color='num_contratos',
                    color_continuous_scale='Blues'
                )

                fig5.update_layout(
                    height=400,
                    showlegend=False,
                    plot_bgcolor=colores_azul['fondo'],
                    paper_bgcolor='white',
                    font={'family': 'Arial, sans-serif', 'color': colores_azul['texto'], 'size': 12},
                    title={'font': {'size': 16, 'color': colores_azul['texto']}, 'x': 0.5},
                    xaxis=dict(gridcolor='lightgray'),
                    yaxis=dict(gridcolor='lightgray')
                )

                fig5.update_traces(
                    texttemplate='%{y:,}',
                    textposition='outside',
                    hovertemplate='A√±o: %{x}<br>Contratos: %{y:,}<extra></extra>'
                )

                fig5.show()

    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo procesar la informaci√≥n temporal: {e}")

print("‚úÖ Visualizaciones mejoradas completadas - Dise√±o profesional en tonos azules")

# VISUALIZACIONES B√ÅSICAS
print("Creando visualizaciones...")

if not df_contratos.empty and 'entidad_limpia' in df_contratos.columns:
    # Gr√°fico 1: Top entidades por n√∫mero de contratos
    top_entidades = df_contratos['entidad_limpia'].value_counts().head(15)
    entidades_cortas = [name[:50] + "..." if len(name) > 50 else name for name in top_entidades.index]

    fig1 = px.bar(
        x=top_entidades.values,
        y=entidades_cortas,
        orientation='h',
        title='Top 15 Entidades por N√∫mero de Contratos',
        labels={'x': 'N√∫mero de Contratos', 'y': 'Entidad'},
        color=top_entidades.values,
        color_continuous_scale='viridis'
    )
    fig1.update_layout(height=600, showlegend=False)
    fig1.show()

if not df_contratos.empty and 'valor_limpio' in df_contratos.columns:
    # Gr√°fico 2: Distribuci√≥n de valores de contratos
    valores_validos = df_contratos[df_contratos['valor_limpio'] > 0]['valor_limpio']

    if not valores_validos.empty:
        fig2 = px.histogram(
            x=np.log10(valores_validos + 1),
            nbins=50,
            title='Distribuci√≥n de Valores de Contratos (Escala Logar√≠tmica)',
            labels={'x': 'Log10(Valor del Contrato)', 'y': 'Frecuencia'}
        )
        fig2.update_layout(height=400)
        fig2.show()

# Gr√°fico 3: An√°lisis temporal si hay fechas
fecha_cols = [col for col in df_contratos.columns if 'fecha' in col.lower()]
if fecha_cols:
    try:
        df_contratos['fecha_parsed'] = pd.to_datetime(df_contratos[fecha_cols[0]], errors='coerce')
        contratos_mensuales = df_contratos.groupby(
            df_contratos['fecha_parsed'].dt.to_period('M')
        ).size()

        if not contratos_mensuales.empty:
            fig3 = px.line(
                x=[str(p) for p in contratos_mensuales.index],
                y=contratos_mensuales.values,
                title='Evoluci√≥n Temporal de Contratos',
                labels={'x': 'Mes-A√±o', 'y': 'N√∫mero de Contratos'}
            )
            fig3.update_layout(height=400)
            fig3.show()
    except:
        print("No se pudo procesar la informaci√≥n temporal")

print("Visualizaciones b√°sicas completadas")

# UNI√ìN DE DATOS DE CONTRATOS Y GRUPOS
print("Uniendo datos de contratos y grupos empresariales...")

if not df_contratos.empty and not df_grupos.empty:
    # Buscar columnas para hacer el join
    codigo_cols_contratos = [col for col in df_contratos.columns if 'codigo' in col.lower() and 'proveedor' in col.lower()]
    codigo_cols_grupos = [col for col in df_grupos.columns if 'codigo' in col.lower()]

    print(f"Columnas de c√≥digo en contratos: {codigo_cols_contratos}")
    print(f"Columnas de c√≥digo en grupos: {codigo_cols_grupos}")

    if codigo_cols_contratos and codigo_cols_grupos:
        # Hacer el join
        df_join = df_contratos.merge(
            df_grupos,
            left_on=codigo_cols_contratos[0],
            right_on=codigo_cols_grupos[0],
            how='left'
        )

        # Crear columna unificada de nombres
        if 'participante_limpio' in df_join.columns and 'proveedor_limpio' in df_join.columns:
            df_join['nombre_final'] = df_join['participante_limpio'].combine_first(df_join['proveedor_limpio'])

        # Calcular valor por participante
        if 'valor_limpio' in df_join.columns and 'participacion_num' in df_join.columns:
            mask_grupo = df_join['participacion_num'] > 0
            df_join['valor_participante'] = 0.0
            df_join.loc[mask_grupo, 'valor_participante'] = (
                df_join.loc[mask_grupo, 'valor_limpio'] *
                df_join.loc[mask_grupo, 'participacion_num'] / 100
            )
            df_join.loc[~mask_grupo, 'valor_participante'] = df_join.loc[~mask_grupo, 'valor_limpio']

        print(f"Join completado: {len(df_join):,} registros")
        print(f"Contratos con grupo: {df_join['participacion_num'].notna().sum():,}")

    else:
        print("No se encontraron columnas compatibles para el join")
        df_join = df_contratos.copy()
else:
    print("Usando solo datos de contratos")
    df_join = df_contratos.copy()

# AN√ÅLISIS DE REDES DE COLABORACI√ìN
print("Creando red de colaboraci√≥n empresarial...")

if 'entidad_limpia' in df_join.columns and 'proveedor_limpio' in df_join.columns:
    # Filtrar proveedores con m√∫ltiples contratos
    conteos_proveedor = df_join['proveedor_limpio'].value_counts()
    proveedores_activos = conteos_proveedor[conteos_proveedor >= 3].index

    df_red = df_join[
        (df_join['proveedor_limpio'].isin(proveedores_activos)) &
        (df_join['entidad_limpia'] != '') &
        (df_join['proveedor_limpio'] != '')
    ]

    print(f"Proveedores activos (‚â•3 contratos): {len(proveedores_activos):,}")
    print(f"Contratos para red: {len(df_red):,}")

    if len(df_red) > 0:
        # Crear red
        G = nx.Graph()
        conexiones = 0

        print("Calculando conexiones...")
        for entidad in tqdm(df_red['entidad_limpia'].unique()[:100]):  # Limitar para performance
            proveedores_entidad = df_red[df_red['entidad_limpia'] == entidad]['proveedor_limpio'].unique()

            # Crear conexiones entre proveedores de la misma entidad
            for p1, p2 in itertools.combinations(proveedores_entidad, 2):
                if G.has_edge(p1, p2):
                    G[p1][p2]['peso'] += 1
                else:
                    G.add_edge(p1, p2, peso=1)
                    conexiones += 1

        print(f"Red creada:")
        print(f"   Nodos (proveedores): {G.number_of_nodes():,}")
        print(f"   Conexiones: {G.number_of_edges():,}")
        print(f"   Densidad: {nx.density(G):.4f}")

        # M√©tricas de centralidad
        if G.number_of_nodes() > 0:
            centralidad = nx.degree_centrality(G)
            top_centrales = sorted(centralidad.items(), key=lambda x: x[1], reverse=True)[:10]

            print(f"\nTOP 10 PROVEEDORES M√ÅS CONECTADOS:")
            for i, (proveedor, cent) in enumerate(top_centrales, 1):
                nombre_corto = proveedor[:50] + "..." if len(proveedor) > 50 else proveedor
                print(f"{i:2d}. {nombre_corto} (centralidad: {cent:.3f})")
    else:
        print("No hay suficientes datos para crear red")
        G = None
else:
    print("Faltan columnas para an√°lisis de redes")
    G = None

# VISUALIZACI√ìN DE LA RED
print("Creando visualizaci√≥n de la red...")

if G and G.number_of_nodes() > 1:
    # Tomar solo los nodos m√°s conectados para mejor visualizaci√≥n
    grados = dict(G.degree())
    top_nodos = sorted(grados.items(), key=lambda x: x[1], reverse=True)[:50]
    nodos_viz = [nodo for nodo, _ in top_nodos]
    G_viz = G.subgraph(nodos_viz)

    print(f"Visualizando {G_viz.number_of_nodes()} nodos m√°s conectados")

    # Calcular posiciones
    pos = nx.spring_layout(G_viz, k=2, iterations=50)

    # Preparar datos para Plotly
    edge_x, edge_y = [], []
    for edge in G_viz.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    node_x, node_y, node_text, node_size = [], [], [], []
    for node in G_viz.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)

        grado = G_viz.degree(node)
        nombre_corto = node[:30] + "..." if len(node) > 30 else node
        node_text.append(f"{nombre_corto}<br>Conexiones: {grado}")
        node_size.append(max(10, min(50, grado * 3)))

    # Crear gr√°fico
    fig_red = go.Figure()

    # Aristas
    fig_red.add_trace(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='lightgray'),
        hoverinfo='none',
        mode='lines',
        showlegend=False
    ))

    # Nodos
    fig_red.add_trace(go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        text=node_text,
        marker=dict(
            size=node_size,
            color=[G_viz.degree(node) for node in G_viz.nodes()],
            colorscale='viridis',
            showscale=True,
            colorbar=dict(title="Conexiones"),
            line=dict(width=1, color='white')
        ),
        showlegend=False
    ))

    fig_red.update_layout(
        title='üï∏Ô∏è Red de Colaboraci√≥n de Proveedores SECOP',
        showlegend=False,
        hovermode='closest',
        margin=dict(b=20, l=5, r=5, t=40),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        width=900,
        height=600
    )

    fig_red.show()
    print("Visualizaci√≥n de red completada")
else:
    print("No hay suficientes conexiones para visualizar")

# DASHBOARD FINAL
print("Creando dashboard completo...")

# Crear subplots
fig_dashboard = make_subplots(
    rows=2, cols=2,
    subplot_titles=[
        'Distribuci√≥n de Valores',
        'Top 10 Entidades',
        'Contratos por Mes',
        'An√°lisis de Sectores'
    ],
    specs=[
        [{"type": "histogram"}, {"type": "bar"}],
        [{"type": "scatter"}, {"type": "pie"}]
    ]
)

# Panel 1: Distribuci√≥n de valores
if 'valor_limpio' in df_join.columns:
    valores_validos = df_join[df_join['valor_limpio'] > 0]['valor_limpio']
    if not valores_validos.empty:
        fig_dashboard.add_trace(
            go.Histogram(
                x=np.log10(valores_validos + 1),
                nbinsx=30,
                name="Valores",
                marker_color='lightblue'
            ),
            row=1, col=1
        )

# Panel 2: Top entidades
if 'entidad_limpia' in df_join.columns:
    top_ent = df_join['entidad_limpia'].value_counts().head(10)
    nombres_cortos = [name[:25] + "..." if len(name) > 25 else name for name in top_ent.index]

    fig_dashboard.add_trace(
        go.Bar(
            x=top_ent.values,
            y=nombres_cortos,
            orientation='h',
            name="Contratos",
            marker_color='lightgreen'
        ),
        row=1, col=2
    )

# Panel 3: Evoluci√≥n temporal
if 'fecha_parsed' in df_join.columns:
    try:
        contratos_mes = df_join.groupby(df_join['fecha_parsed'].dt.to_period('M')).size()
        if not contratos_mes.empty:
            fig_dashboard.add_trace(
                go.Scatter(
                    x=[str(p) for p in contratos_mes.index],
                    y=contratos_mes.values,
                    mode='lines+markers',
                    name="Contratos/Mes",
                    line=dict(color='orange')
                ),
                row=2, col=1
            )
    except:
        pass

# Panel 4: Sectores
sector_cols = [col for col in df_join.columns if 'sector' in col.lower()]
if sector_cols:
    sectores = df_join[sector_cols[0]].value_counts().head(8)
    sectores_cortos = [s[:20] + "..." if len(s) > 20 else s for s in sectores.index]

    fig_dashboard.add_trace(
        go.Pie(
            labels=sectores_cortos,
            values=sectores.values,
            name="Sectores"
        ),
        row=2, col=2
    )

# Configurar layout
fig_dashboard.update_layout(
    height=800,
    title_text="üìä Dashboard Completo - An√°lisis SECOP Bogot√°",
    title_x=0.5,
    showlegend=False
)

fig_dashboard.show()
print("Dashboard completado")

# CONCLUSIONES Y INSIGHTS
print("RESUMEN DE INSIGHTS ENCONTRADOS")
print("=" * 60)

if not df_join.empty:
    # Insights financieros
    if 'valor_limpio' in df_join.columns:
        valor_total = df_join['valor_limpio'].sum()
        print(f"INSIGHTS FINANCIEROS:")
        print(f"   ‚Ä¢ Total analizado: ${valor_total/1_000_000_000_000:.2f} billones COP")
        print(f"   ‚Ä¢ Contratos analizados: {len(df_join):,}")

    # Insights de entidades
    if 'entidad_limpia' in df_join.columns:
        total_entidades = df_join['entidad_limpia'].nunique()
        entidad_top = df_join['entidad_limpia'].value_counts().index[0]
        contratos_top = df_join['entidad_limpia'].value_counts().iloc[0]

        print(f"\nINSIGHTS DE ENTIDADES:")
        print(f"   ‚Ä¢ {total_entidades:,} entidades diferentes contratan")
        print(f"   ‚Ä¢ La entidad m√°s activa: {entidad_top[:60]}")
        print(f"   ‚Ä¢ Representa el {(contratos_top/len(df_join)*100):.1f}% de todos los contratos")

    # Insights de proveedores
    if 'proveedor_limpio' in df_join.columns:
        total_proveedores = df_join['proveedor_limpio'].nunique()
        proveedor_top = df_join['proveedor_limpio'].value_counts().index[0]
        contratos_prov_top = df_join['proveedor_limpio'].value_counts().iloc[0]

        print(f"\nINSIGHTS DE PROVEEDORES:")
        print(f"   ‚Ä¢ {total_proveedores:,} proveedores √∫nicos")
        print(f"   ‚Ä¢ Proveedor m√°s exitoso: {proveedor_top[:60]}")
        print(f"   ‚Ä¢ Con {contratos_prov_top:,} contratos")

    # Insights de red
    if G and G.number_of_nodes() > 0:
        print(f"\nINSIGHTS DE RED:")
        print(f"   ‚Ä¢ {G.number_of_nodes():,} proveedores forman la red")
        print(f"   ‚Ä¢ {G.number_of_edges():,} conexiones de colaboraci√≥n")
        print(f"   ‚Ä¢ Densidad de red: {nx.density(G):.4f}")

        componentes = list(nx.connected_components(G))
        if componentes:
            comp_mayor = max(componentes, key=len)
            print(f"   ‚Ä¢ Componente principal: {len(comp_mayor)} proveedores conectados")

print(f"\nAN√ÅLISIS COMPLETADO")
print(f"Has analizado exitosamente los datos de contrataci√≥n p√∫blica")
print(f"Visualizaciones creadas: Dashboard, Red de colaboraci√≥n, Gr√°ficos")
print(f"Insights generados: Patrones de contrataci√≥n, Redes empresariales")
print(f"\n¬°Felicidades! Has completado un an√°lisis profesional de datos p√∫blicos")

"""# ¬°An√°lisis Completado!

## Lo que has logrado:
- **Descargaste datos reales** del gobierno colombiano
- **Procesaste y limpiaste** informaci√≥n compleja
- **Creaste visualizaciones profesionales** interactivas
- **Analizaste redes de colaboraci√≥n** empresarial
- **Generaste insights valiosos** sobre contrataci√≥n p√∫blica

## Pr√≥ximos pasos sugeridos:
1. **Experimenta** cambiando los filtros (otras ciudades, a√±os)
2. **Personaliza** las visualizaciones con diferentes colores/estilos
3. **Agrega nuevos an√°lisis** (anomal√≠as, clustering, etc.)
4. **Guarda** tus hallazgos en archivos
5. **Comparte** tu trabajo en redes sociales

## Ideas para expandir:
- Analizar otros departamentos de Colombia
- Comparar patrones entre diferentes a√±os
- Detectar anomal√≠as en valores de contratos
- Crear un sistema de alertas para contratos grandes
- Desarrollar un dashboard en tiempo real

---

**¬°Has demostrado que puedes hacer an√°lisis de datos de nivel profesional!**

*¬øTe gust√≥ este an√°lisis? Dale una estrella al repositorio en GitHub*
"""