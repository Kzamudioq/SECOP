# -*- coding: utf-8 -*-
"""analisis_secop_completo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-s1LCCHQKdb5cI6OicRgsxYalWGZzEgN

# **An√°lisis de Datos SECOP - Colombia**


## An√°lisis de Contrataci√≥n P√∫blica

**¬øQu√© vamos a hacer?**
-  Descargar datos reales de contrataci√≥n p√∫blica
-  Limpiar y procesar la informaci√≥n
-  Crear visualizaciones interactivas
-  Analizar redes de colaboraci√≥n
-  Detectar patrones interesantes

**Solo ejecuta las celdas una por una y disfruta del an√°lisis**

## Instalaci√≥n de librerias
"""

#  INSTALACI√ìN Y CONFIGURACI√ìN INICIAL
print(" Configurando entorno de an√°lisis...")

# Instalar librer√≠as necesarias
!pip install fuzzywuzzy python-Levenshtein networkx plotly kaleido -q

# ====================================================================
# LIBRER√çAS PARA AN√ÅLISIS DE DATOS, SOLICITUDES Y VISUALIZACI√ìN
# ====================================================================

import pandas as pd        # Manipulaci√≥n y an√°lisis de datos (tablas tipo Excel o CSV)
import numpy as np          # C√°lculos num√©ricos y manejo de arreglos (vectores, matrices)
import requests             # Env√≠o de solicitudes HTTP (consultar APIs o p√°ginas web)
import time                 # Control de tiempos y pausas en la ejecuci√≥n del programa
import warnings             # Ocultar o controlar advertencias del sistema

# ====================================================================
# LIBRER√çAS PARA VISUALIZACI√ìN INTERACTIVA CON PLOTLY
# ====================================================================

import plotly.express as px # Gr√°ficos interactivos sencillos (barras, dispersi√≥n, mapas, etc.)
import plotly.graph_objects as go   # Gr√°ficos avanzados y personalizados (m√°s control)
from plotly.subplots import make_subplots  # Permite combinar varios gr√°ficos en una misma figura
import plotly.io as pio     # Configuraci√≥n de visualizaci√≥n y exportaci√≥n (HTML, PNG, etc.)
#import matplotlib.pyplot as plt

# ====================================================================
# LIBRER√çAS PARA AN√ÅLISIS DE REDES, COMBINACIONES Y COINCIDENCIAS DE TEXTO
# ====================================================================

import networkx as nx       # Creaci√≥n y an√°lisis de grafos/redes (nodos y relaciones)
import itertools            # Combinaciones, permutaciones y operaciones sobre iteradores
from fuzzywuzzy import fuzz, process  # Comparaci√≥n de texto difusa (emparejamiento aproximado)

# ====================================================================
# LIBRER√çA PARA MOSTRAR BARRAS DE PROGRESO
# ====================================================================

from tqdm import tqdm        # Barra de progreso en loops largos para seguimiento visual

# Configuraciones
pio.renderers.default = "colab"
warnings.filterwarnings('ignore')

print("‚úÖ Herramientas listas!")

"""## Descarga de datos"""

def descargar_datos(cuantos_registros=100000):
    """
    Descarga una muestra peque√±a de datos de SECOP
    Perfecto para empezar a aprender
    """
    print(f"Descargando {cuantos_registros:,} contratos de ejemplo...")

    # URL oficial de datos del gobierno
    url = "https://www.datos.gov.co/resource/jbjy-vk9h.json"

    # Configuraci√≥n simple
    params = {
        "$limit": cuantos_registros,
        "$where": "departamento = 'Distrito Capital de Bogot√°'"
    }

    try:
        # Descargar datos
        response = requests.get(url, params=params, timeout=30)
        datos = response.json()

        # Convertir a tabla
        df = pd.DataFrame(datos)

        print(f"¬°Descarga exitosa! {len(df):,} contratos obtenidos")
        return df

    except Exception as error:
        print(f"Error al descargar: {error}")
        return pd.DataFrame()

# Descargar datos
df_contratos = descargar_datos(100000)

"""## Exploraci√≥n de datos"""

print("Primeros 3 contratos:")
print(df_contratos.head(3))

# Ver las primeras filas
pd.set_option('display.max_columns', None)

print("Primeros 3 contratos:")
print(df_contratos.head(3))

# Ver informaci√≥n b√°sica
print("Informaci√≥n b√°sica:")
print(f"   ‚Ä¢ N√∫mero de filas: {len(df_contratos):,}")
print(f"   ‚Ä¢ N√∫mero de columnas: {len(df_contratos.columns)}")

# Ver nombres de columnas
print("\nColumnas disponibles:")
for i, col in enumerate(df_contratos.columns, 1):
    print(f"   {i:2d}. {col}")

# Imprimir el tipo de variable

pd.set_option('display.max_columns', None)   # Mostrar todas las columnas
pd.set_option('display.width', None)         # Evita que se corten por ancho
pd.set_option('display.max_colwidth', None)  # Muestra todo el texto de cada columna

print("\nTipos de datos de todas las columnas:\n")
print(df_contratos.dtypes)

"""# Analisis de variables"""

# N√∫mero total de contratos
print("N√∫mero total de registros:", df_contratos["id_contrato"].count())

# Cu√°ntos contratos est√°n repetidos
duplicados = df_contratos["id_contrato"].duplicated().sum()
print("Contratos duplicados:", duplicados)

# Cu√°ntos valores nulos tiene la columna
print("Valores nulos en id_contrato:", df_contratos["id_contrato"].isna().sum())

# Ver el rango de a√±os que cubren los contratos
print(df_contratos['fecha_firma'].dt.year.min(), df_contratos['fecha_firma'].dt.year.max())

"""‚òù
*   **Problema:** El c√≥digo intenta acceder a la columna 'fecha_firma' en el DataFrame df_contratos, pero esta columna no existe en los datos cargados
*   **Causa:** Hay un error de tipeo en el nombre de la columna o los datos no contienen esa columna espec√≠fica - necesitas verificar el nombre exacto usando df_contratos.columns para ver las columnas disponibles

**Paso 1: Primero ejecuten este c√≥digo para ver qu√© columnas tienen disponibles:**
"""

print("Columnas disponibles:")
print(df_contratos.columns.tolist())

"""**Paso 2: Una vez identifiquen el nombre correcto de la columna de fecha, reemplacen 'fecha_firma' en el c√≥digo original por el nombre exacto que aparezca en la lista (por ejemplo, podr√≠a ser 'fecha_de_firma', 'fecha_contrato', etc.)**

"""

try:
    # Intentar ejecutar el c√≥digo original
    print(df_contratos['fecha_firma'].dt.year.min(), df_contratos['fecha_firma'].dt.year.max())
except KeyError:
    # Si la columna no existe, mostrar las disponibles y solicitar el nombre correcto
    print("Error: La columna 'fecha_firma' no existe.")
    print("\nColumnas disponibles en el DataFrame:")
    print(df_contratos.columns.tolist())

    # Solicitar el nombre correcto
    nombre_columna = input("\nIngrese el nombre exacto de la columna de fecha que desea usar: ")

    try:
        # Convertir a datetime si no lo es ya
        df_contratos[nombre_columna] = pd.to_datetime(df_contratos[nombre_columna], errors='coerce')

        # Ejecutar con la columna correcta
        print(f"\nRango de a√±os en la columna '{nombre_columna}':")
        print(df_contratos[nombre_columna].dt.year.min(), df_contratos[nombre_columna].dt.year.max())

    except AttributeError:
        print(f"Error: La columna '{nombre_columna}' no contiene datos de fecha v√°lidos.")
    except Exception as e:
        print(f"Error procesando la columna '{nombre_columna}': {e}")

"""**Nota:** Vamos a filtrar los datos desde **2021** en adelante, ya que los datos anteriores contienen demasiados errores y valores inconsistentes que afectan la calidad del an√°lisis

"""

# Filtrar datos desde 2021 en adelante para trabajar con informaci√≥n m√°s confiable
# Los datos anteriores contienen demasiados errores

# Convertir la columna a formato de fecha
df_contratos['fecha_de_firma'] = pd.to_datetime(df_contratos['fecha_de_firma'])

# Filtrar desde 2021
df_contratos = df_contratos[df_contratos['fecha_de_firma'].dt.year >= 2021]

# Ver el rango de a√±os filtrados
print("Rango de a√±os despu√©s del filtro:")
print(df_contratos['fecha_de_firma'].dt.year.min(), df_contratos['fecha_de_firma'].dt.year.max())

"""Antes de continuar con el an√°lisis, es importante conocer los **diferentes estados** que pueden tener los contratos en el dataset. Esto nos ayudar√° a entender el ciclo de vida de los contratos y filtrar la informaci√≥n seg√∫n el estado que nos interese analizar."""

# Ver valores √∫nicos de estado_contrato
print("=== VALORES √öNICOS EN ESTADO_CONTRATO ===")
estados_unicos = df_contratos['estado_contrato'].value_counts()
print(estados_unicos)

print(f"\nTotal de estados diferentes: {df_contratos['estado_contrato'].nunique()}")
print(f"Valores √∫nicos: {df_contratos['estado_contrato'].unique()}")

# Visualizaci√≥n
plt.figure(figsize=(10, 6))
plt.bar(estados_unicos.index, estados_unicos.values, color='lightblue')
plt.title('Distribuci√≥n de Estados de Contrato')
plt.xlabel('Estado del Contrato')
plt.ylabel('N√∫mero de Contratos')
plt.xticks(rotation=45)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""‚è© Ahora crearemos una gr√°fica que muestre la relaci√≥n entre las fechas de firma y los contratos (usando el id_contrato como identificador √∫nico) para analizar la distribuci√≥n temporal de la contrataci√≥n p√∫blica.

"""

# Eliminar contratos duplicados basados en id_contrato para asegurar que cada contrato sea √∫nico
df_contratos_unicos = df_contratos.drop_duplicates(subset=['id_contrato'])

# Contar cu√°ntos contratos √∫nicos se firmaron por fecha
contratos_por_fecha = df_contratos_unicos['fecha_de_firma'].value_counts().sort_index()

# Crear la gr√°fica
plt.figure(figsize=(12, 6))
plt.plot(contratos_por_fecha.index, contratos_por_fecha.values)
plt.title('N√∫mero de Contratos √önicos Firmados por Fecha')
plt.xlabel('Fecha de Firma')
plt.ylabel('Cantidad de Contratos')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

"""Necesitas importar las librer√≠as para hacer gr√°ficas. Agrega esto al inicio en IMPORTACI√ìN DE LIBRERIAS

**import matplotlib.pyplot as plt**
"""

# Eliminar contratos duplicados basados en id_contrato para asegurar que cada contrato sea √∫nico
df_contratos_unicos = df_contratos.drop_duplicates(subset=['id_contrato'])

# Contar cu√°ntos contratos √∫nicos se firmaron por fecha
contratos_por_fecha = df_contratos_unicos['fecha_de_firma'].value_counts().sort_index()

# Crear la gr√°fica
plt.figure(figsize=(12, 6))
plt.plot(contratos_por_fecha.index, contratos_por_fecha.values)
plt.title('N√∫mero de contratos √∫nicos firmados por fecha')
plt.xlabel('Fecha de Firma')
plt.ylabel('Cantidad de Contratos')
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

"""Ahora crearemos una gr√°fica de barras que nos muestre cu√°ntos **contratos √∫nicos se firmaron cada a√±o**. Esto nos permitir√° identificar f√°cilmente en qu√© a√±os hubo mayor o menor actividad de contrataci√≥n p√∫blica."""

# Agrupar contratos √∫nicos por a√±o
contratos_por_a√±o = df_contratos_unicos['fecha_de_firma'].dt.year.value_counts().sort_index()

# Crear la gr√°fica de barras
plt.figure(figsize=(10, 6))
plt.bar(contratos_por_a√±o.index, contratos_por_a√±o.values, color='skyblue')
plt.title('N√∫mero de Contratos √önicos por A√±o')
plt.xlabel('A√±o')
plt.ylabel('Cantidad de Contratos')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Mostrar los n√∫meros exactos
print("Contratos por a√±o:")
for a√±o, cantidad in contratos_por_a√±o.items():
    print(f"{a√±o}: {cantidad} contratos")

"""Ahora crearemos un gr√°fico de torta (pie chart) que nos muestre qu√© porcentaje de **contratos √∫nicos corresponde a cada sector**. Esto nos ayudar√° a identificar cu√°les son los sectores que m√°s contratan."""

# Contar contratos √∫nicos por sector
contratos_por_sector = df_contratos_unicos['sector'].value_counts()

# Crear el gr√°fico de torta
plt.figure(figsize=(8, 8))
plt.pie(contratos_por_sector.values, labels=contratos_por_sector.index, autopct='%1.1f%%', startangle=90)
plt.title('Distribuci√≥n de Contratos √önicos por Sector')
plt.axis('equal')  # Para que el c√≠rculo se vea perfecto
plt.tight_layout()
plt.show()

# Mostrar los n√∫meros exactos
print("Contratos por sector:")
for sector, cantidad in contratos_por_sector.items():
    print(f"{sector}: {cantidad} contratos")

"""El gr√°fico anterior presenta **saturaci√≥n visual con porcentajes superpuestos** y demasiadas categor√≠as peque√±as, lo que dificulta su lectura e interpretaci√≥n. Necesitamos crear una versi√≥n m√°s limpia y clara."""

# Contar contratos √∫nicos por sector
contratos_por_sector = df_contratos_unicos['sector'].value_counts()

# Crear gr√°fico de barras horizontales para mejor visualizaci√≥n
plt.figure(figsize=(12, 8))
contratos_por_sector.plot(kind='barh', color='skyblue')
plt.title('N√∫mero de Contratos √önicos por Sector')
plt.xlabel('Cantidad de Contratos')
plt.ylabel('Sector')
plt.grid(axis='x', alpha=0.3)
plt.tight_layout()
plt.show()

# Contar contratos √∫nicos por sector
contratos_por_sector = df_contratos_unicos['sector'].value_counts()

# Tomar solo los 5 sectores principales para mejor visualizaci√≥n
top_sectores = contratos_por_sector.head(5)

# Crear el gr√°fico de torta mejorado
plt.figure(figsize=(12, 8))
colors = ['#1f77b4', '#aec7e8', '#2ca02c', '#98df8a', '#17becf', '#9edae5', '#2e8b57', '#66cdaa', '#4682b4', '#87ceeb']

plt.pie(top_sectores.values,
        labels=top_sectores.index,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors,
        textprops={'fontsize': 10})
plt.title('Top 5 sectores con m√°s contratos √∫nicos', fontsize=14, pad=20)
plt.tight_layout()
plt.show()

# Mostrar los n√∫meros exactos
print("Top 5 sectores con m√°s contratos:")
for sector, cantidad in top_sectores.items():
    print(f"{sector}: {cantidad} contratos")

"""# Aplicaci√≥n de Lenguaje natural como asistente de programaci√≥n

**Prompts:** "Tengo un dataset de contratos p√∫blicos con las columnas valor_del_contrato, valor_pagado, valor_pendiente_de_pago. Ay√∫dame a analizar la distribuci√≥n de estos valores y detectar posibles inconsistencias o valores at√≠picos."
"""

# An√°lisis de valores monetarios
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Estad√≠sticas b√°sicas de valores monetarios
columnas_monetarias = ['valor_del_contrato', 'valor_pagado', 'valor_pendiente_de_pago', 'valor_facturado']

print("=== ESTAD√çSTICAS DE VALORES MONETARIOS ===")
for col in columnas_monetarias:
    if col in df_contratos.columns:
        print(f"\n{col.upper()}:")
        print(f"Promedio: ${df_contratos[col].mean():,.0f}")
        print(f"Mediana: ${df_contratos[col].median():,.0f}")
        print(f"M√°ximo: ${df_contratos[col].max():,.0f}")
        print(f"M√≠nimo: ${df_contratos[col].min():,.0f}")

# Visualizaci√≥n de distribuci√≥n
fig, axes = plt.subplots(2, 2, figsize=(15, 10))
axes = axes.flatten()

for i, col in enumerate(columnas_monetarias[:4]):
    if col in df_contratos.columns:
        # Usar escala logar√≠tmica para mejor visualizaci√≥n
        df_contratos[col].hist(bins=50, ax=axes[i], log=True)
        axes[i].set_title(f'Distribuci√≥n de {col}')
        axes[i].set_xlabel('Valor (escala log)')
        axes[i].set_ylabel('Frecuencia')

plt.tight_layout()
plt.show()

# Detectar valores at√≠picos
print("\n=== DETECCI√ìN DE VALORES AT√çPICOS ===")
for col in ['valor_del_contrato']:
    Q1 = df_contratos[col].quantile(0.25)
    Q3 = df_contratos[col].quantile(0.75)
    IQR = Q3 - Q1
    outliers = df_contratos[(df_contratos[col] < Q1 - 1.5*IQR) | (df_contratos[col] > Q3 + 1.5*IQR)]
    print(f"{col}: {len(outliers)} valores at√≠picos detectados")

# Limpiar y convertir columnas monetarias
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Funci√≥n para limpiar valores monetarios
def limpiar_valor_monetario(valor):
    if pd.isna(valor):
        return 0
    if isinstance(valor, str):
        # Remover caracteres no num√©ricos excepto puntos y comas
        valor_limpio = ''.join(c for c in valor if c.isdigit() or c in '.,')
        # Si est√° vac√≠o despu√©s de limpiar, retornar 0
        if not valor_limpio:
            return 0
        try:
            # Convertir a float
            return float(valor_limpio.replace(',', ''))
        except:
            return 0
    return valor

# Limpiar columnas monetarias
columnas_monetarias = ['valor_del_contrato', 'valor_pagado', 'valor_pendiente_de_pago', 'valor_facturado']

print("Limpiando datos monetarios...")
for col in columnas_monetarias:
    if col in df_contratos.columns:
        df_contratos[col] = df_contratos[col].apply(limpiar_valor_monetario)

print("=== ESTAD√çSTICAS DE VALORES MONETARIOS ===")
for col in columnas_monetarias:
    if col in df_contratos.columns:
        print(f"\n{col.upper()}:")
        print(f"Promedio: ${df_contratos[col].mean():,.0f}")
        print(f"Mediana: ${df_contratos[col].median():,.0f}")
        print(f"M√°ximo: ${df_contratos[col].max():,.0f}")
        print(f"M√≠nimo: ${df_contratos[col].min():,.0f}")

# Visualizaci√≥n de distribuci√≥n
fig, axes = plt.subplots(2, 2, figsize=(15, 10))
axes = axes.flatten()

for i, col in enumerate(columnas_monetarias[:4]):
    if col in df_contratos.columns:
        # Filtrar valores > 0 para escala logar√≠tmica
        valores_positivos = df_contratos[df_contratos[col] > 0][col]
        valores_positivos.hist(bins=50, ax=axes[i], log=True)
        axes[i].set_title(f'Distribuci√≥n de {col}')
        axes[i].set_xlabel('Valor (escala log)')
        axes[i].set_ylabel('Frecuencia')

plt.tight_layout()
plt.show()

# Detectar valores at√≠picos
print("\n=== DETECCI√ìN DE VALORES AT√çPICOS ===")
for col in ['valor_del_contrato']:
    Q1 = df_contratos[col].quantile(0.25)
    Q3 = df_contratos[col].quantile(0.75)
    IQR = Q3 - Q1
    outliers = df_contratos[(df_contratos[col] < Q1 - 1.5*IQR) | (df_contratos[col] > Q3 + 1.5*IQR)]
    print(f"{col}: {len(outliers)} valores at√≠picos detectados")

"""**Prompts:** "Mi dataset tiene fechas de firma, inicio y fin de contratos. Quiero analizar patrones temporales: ¬øEn qu√© meses/a√±os hay m√°s contrataci√≥n? ¬øCu√°l es la duraci√≥n promedio de los contratos?"
"""

# An√°lisis temporal de contrataci√≥n
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Convertir columnas de fechas a datetime
print("Convirtiendo fechas...")
df_contratos['fecha_de_firma'] = pd.to_datetime(df_contratos['fecha_de_firma'], errors='coerce')
df_contratos['fecha_de_inicio_del_contrato'] = pd.to_datetime(df_contratos['fecha_de_inicio_del_contrato'], errors='coerce')
df_contratos['fecha_de_fin_del_contrato'] = pd.to_datetime(df_contratos['fecha_de_fin_del_contrato'], errors='coerce')

# Filtrar datos desde 2021 (como establecimos antes)
df_temp = df_contratos[df_contratos['fecha_de_firma'].dt.year >= 2021].copy()

# Calcular duraci√≥n de contratos
df_temp['duracion_dias'] = (df_temp['fecha_de_fin_del_contrato'] - df_temp['fecha_de_inicio_del_contrato']).dt.days

print("=== AN√ÅLISIS TEMPORAL DE CONTRATOS ===")

# Crear visualizaciones
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. Contratos por a√±o
contratos_a√±o = df_temp['fecha_de_firma'].dt.year.value_counts().sort_index()
axes[0,0].bar(contratos_a√±o.index, contratos_a√±o.values, color='skyblue')
axes[0,0].set_title('Contratos por A√±o')
axes[0,0].set_xlabel('A√±o')
axes[0,0].set_ylabel('N√∫mero de Contratos')
axes[0,0].grid(True, alpha=0.3)

# 2. Contratos por mes
contratos_mes = df_temp['fecha_de_firma'].dt.month.value_counts().sort_index()
meses = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic']
axes[0,1].bar(contratos_mes.index, contratos_mes.values, color='lightgreen')
axes[0,1].set_title('Contratos por Mes (Todos los A√±os)')
axes[0,1].set_xlabel('Mes')
axes[0,1].set_ylabel('N√∫mero de Contratos')
axes[0,1].set_xticks(range(1, 13))
axes[0,1].set_xticklabels(meses, rotation=45)
axes[0,1].grid(True, alpha=0.3)

# 3. Valor total por a√±o
valor_a√±o = df_temp.groupby(df_temp['fecha_de_firma'].dt.year)['valor_del_contrato'].sum()
axes[1,0].bar(valor_a√±o.index, valor_a√±o.values/1e9, color='orange')
axes[1,0].set_title('Valor Total Contratado por A√±o')
axes[1,0].set_xlabel('A√±o')
axes[1,0].set_ylabel('Valor (Miles de Millones COP)')
axes[1,0].grid(True, alpha=0.3)

# 4. Duraci√≥n promedio de contratos
# Filtrar duraciones v√°lidas (mayores a 0 y menores a 3650 d√≠as = 10 a√±os)
df_duracion = df_temp[(df_temp['duracion_dias'] > 0) & (df_temp['duracion_dias'] < 3650)]
duracion_a√±o = df_duracion.groupby(df_duracion['fecha_de_firma'].dt.year)['duracion_dias'].mean()
axes[1,1].plot(duracion_a√±o.index, duracion_a√±o.values, marker='o', color='red', linewidth=2)
axes[1,1].set_title('Duraci√≥n Promedio de Contratos por A√±o')
axes[1,1].set_xlabel('A√±o')
axes[1,1].set_ylabel('D√≠as')
axes[1,1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Estad√≠sticas detalladas
print("=== ESTAD√çSTICAS TEMPORALES DETALLADAS ===")

print(f"\nüìÖ CONTRATOS POR A√ëO:")
for a√±o, cantidad in contratos_a√±o.items():
    valor_total = valor_a√±o.get(a√±o, 0)
    print(f"  {a√±o}: {cantidad:,} contratos - ${valor_total:,.0f} COP")

print(f"\nüìÖ CONTRATOS POR MES (promedio todos los a√±os):")
for i, mes in enumerate(meses, 1):
    cantidad = contratos_mes.get(i, 0)
    print(f"  {mes}: {cantidad:,} contratos")

print(f"\n‚è±Ô∏è DURACI√ìN DE CONTRATOS:")
duraciones_validas = df_temp['duracion_dias'][(df_temp['duracion_dias'] > 0) & (df_temp['duracion_dias'] < 3650)]
print(f"  Duraci√≥n promedio: {duraciones_validas.mean():.0f} d√≠as ({duraciones_validas.mean()/30:.1f} meses)")
print(f"  Duraci√≥n mediana: {duraciones_validas.median():.0f} d√≠as ({duraciones_validas.median()/30:.1f} meses)")
print(f"  Duraci√≥n m√≠nima: {duraciones_validas.min():.0f} d√≠as")
print(f"  Duraci√≥n m√°xima: {duraciones_validas.max():.0f} d√≠as ({duraciones_validas.max()/365:.1f} a√±os)")

# An√°lisis adicional: d√≠as de la semana
print(f"\nüìÖ CONTRATOS POR D√çA DE LA SEMANA:")
dias_semana = ['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado', 'Domingo']
contratos_dia_semana = df_temp['fecha_de_firma'].dt.day_of_week.value_counts().sort_index()
for i, dia in enumerate(dias_semana):
    cantidad = contratos_dia_semana.get(i, 0)
    print(f"  {dia}: {cantidad:,} contratos")

# Picos y valles de contrataci√≥n
mes_mayor = contratos_mes.idxmax()
mes_menor = contratos_mes.idxmin()
a√±o_mayor = contratos_a√±o.idxmax()
a√±o_menor = contratos_a√±o.idxmin()

print(f"\nüîç PATRONES IDENTIFICADOS:")
print(f"  Mes con m√°s contrataci√≥n: {meses[mes_mayor-1]} ({contratos_mes[mes_mayor]:,} contratos)")
print(f"  Mes con menos contrataci√≥n: {meses[mes_menor-1]} ({contratos_mes[mes_menor]:,} contratos)")
print(f"  A√±o con m√°s contrataci√≥n: {a√±o_mayor} ({contratos_a√±o[a√±o_mayor]:,} contratos)")
print(f"  A√±o con menos contrataci√≥n: {a√±o_menor} ({contratos_a√±o[a√±o_menor]:,} contratos)")

"""**Prompts:** "Tengo datos de entidades contratantes y sectores. Ay√∫dame a identificar qu√© entidades contratan m√°s, en qu√© sectores se concentra el gasto p√∫blico y crear visualizaciones claras."

**Prompts:** "Mi dataset incluye modalidades de contrataci√≥n (m√≠nima cuant√≠a, licitaci√≥n, etc.). ¬øPuedes ayudarme a analizar qu√© modalidades se usan m√°s y si hay relaci√≥n con los montos?"

**Prompts:** "Tengo un dataset de contratos con muchas columnas. Ay√∫dame a identificar datos faltantes, inconsistencias entre fechas, y problemas de calidad que deba limpiar antes del an√°lisis."

**Prompts:** "Quiero analizar los proveedores: ¬øHay concentraci√≥n en pocos proveedores? ¬øQu√© tipos de empresas (pymes vs grandes) obtienen m√°s contratos?"

# ¬°An√°lisis Completado!

## Lo que has logrado:
- **Trabajaste con datos reales** de contrataci√≥n p√∫blica colombiana (SECOP)
- **Limpiaste y transformaste** datos complejos con valores mixtos
- **Filtraste informaci√≥n** desde 2021 para mayor calidad de datos
- **Creaste m√∫ltiples visualizaciones** (gr√°ficos de barras, tortas, l√≠neas temporales)
- **Analizaste patrones temporales** de contrataci√≥n por a√±os, meses y sectores
- **Exploraste distribuciones monetarias** y detectaste valores at√≠picos
- **Investigaste proveedores** y su participaci√≥n en el mercado p√∫blico

## Lo que descubriste:
- **Patrones estacionales** en la contrataci√≥n p√∫blica
- **Sectores dominantes** en la contrataci√≥n (Transporte, TIC, etc.)
- **Distribuci√≥n de contratos** entre PYMES y grandes empresas
- **Valores t√≠picos y at√≠picos** en los montos contratados
- **Estados de contratos** y su distribuci√≥n

## Pr√≥ximos pasos sugeridos:
1. **Experimenta** con diferentes filtros (sectores espec√≠ficos, rangos de valores)
2. **Personaliza** las visualizaciones con paletas de colores profesionales
3. **Profundiza** en an√°lisis por departamentos o ciudades espec√≠ficas
4. **Analiza correlaciones** entre variables (modalidad vs valor, sector vs duraci√≥n)
5. **Exporta** tus gr√°ficos y datos limpios para presentaciones

## Ideas para expandir:
- Analizar eficiencia de diferentes modalidades de contrataci√≥n
- Detectar patrones sospechosos o anomal√≠as en la contrataci√≥n
- Comparar rendimiento de PYMES vs grandes empresas
- Crear an√°lisis predictivos de tendencias futuras
- Desarrollar indicadores de transparencia y competencia

## Habilidades desarrolladas:
- **Limpieza de datos** con pandas
- **Visualizaci√≥n** con matplotlib
- **An√°lisis exploratorio** de datasets complejos
- **Interpretaci√≥n** de datos gubernamentales
- **Pensamiento anal√≠tico** aplicado a pol√≠ticas p√∫blicas

---

**¬°Has completado un an√°lisis profesional de datos p√∫blicos!**
*Estas habilidades son altamente valoradas en ciencia de datos, consultor√≠a y an√°lisis de pol√≠ticas p√∫blicas.*
"""